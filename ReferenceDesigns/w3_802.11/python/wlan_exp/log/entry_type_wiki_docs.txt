== WLAN Exp v1.5.0   Log Entry Types ==

----

=== Entry Type NODE_INFO ===
Details about the node hardware and its configuration. Node info values are static after boot.

Entry type ID: 1

||=  Field Name  =||=  Data Type  =||=  Description  =||
|| timestamp ||  uint64  || Microsecond timer value at time of log entry creation ||
|| node_type ||  uint32  || Node type as 4 byte value: [b0 b1 b2 b3]:[[BR]] b0: Always 0x00 for 802.11 ref design nodes[[BR]] b1: Always 0x01 for 802.11 ref design nodes[[BR]] b2: CPU High application: 0x1 = AP, 0x2 = STA, 0x3 = IBSS[[BR]] b3: CPU Low application: 0x1 = DCF, 0x2 = NOMAC ||
|| node_id ||  uint32  || Node ID, as set during wlan_exp init ||
|| hw_generation ||  uint32  || WARP hardware generation: 3 for WARP v3 ||
|| serial_num ||  uint32  || Serial number of WARP board ||
|| fpga_dna ||  uint64  || DNA value of node FPGA ||
|| version ||  uint32  || wlan_exp version, as packed values [(u8)major (u8)minor (u16)rev] ||
|| wlan_scheduler_resolution ||  uint32  || Minimum interval in microseconds of the WLAN scheduler ||
|| wlan_mac_addr ||  uint64  || Node MAC address, 6 bytes in lower 48-bits of u64 ||
|| wlan_max_tx_power_dbm ||  int32  || Maximum transmit power ||
|| wlan_min_tx_power_dbm ||  int32  || Minimum transmit power ||


----

=== Entry Type EXP_INFO ===
Header for generic experiment info entries created by the user application. The payload of the EXP_INFO entry is not described by the Python entry type. User code must access the payload in the binary log data directly.

Entry type ID: 2

||=  Field Name  =||=  Data Type  =||=  Description  =||
|| timestamp ||  uint64  || Microsecond timer value at time of log entry creation ||
|| info_type ||  uint16  || Exp info type (arbitrary value supplied by application ||
|| info_len ||  uint16  || Exp info length (describes arbitrary payload supplied by application ||
|| info_payload ||  uint32  || Exp info payload ||


----

=== Entry Type NODE_TEMPERATURE ===
Record of the FPGA system monitor die temperature. This entry is only created when directed by a wlan_exp command. Temperature values are stored as 32-bit unsigned integers. To convert to degrees Celcius, apply (((float)temp_u32)/(65536.0*0.00198421639)) - 273.15

Entry type ID: 4

||=  Field Name  =||=  Data Type  =||=  Description  =||
|| timestamp ||  uint64  || Microsecond timer value at time of log entry creation ||
|| node_id ||  uint32  || wlan_exp node ID ||
|| serial_num ||  uint32  || Node serial number ||
|| temp_current ||  uint32  || Current FPGA die temperature ||
|| temp_min ||  uint32  || Minimum FPGA die temperature since FPGA configuration or sysmon reset ||
|| temp_max ||  uint32  || Maximum FPGA die temperature since FPGA configuration or sysmon reset ||


----

=== Entry Type TIME_INFO ===
Record of a time base event at the node. This log entry is used to enable parsing of log data recorded before and after changes to the node's microsecond MAC timer. This entry also allows a wlan_exp controler to write the current host time to the node log without affecting the node's timer value. This enables adjustment of log entry timestamps to real timestamps in post-proessing.

Entry type ID: 6

||=  Field Name  =||=  Data Type  =||=  Description  =||
|| timestamp ||  uint64  || Microsecond MAC timer value at time of log entry creation before any time change is applied ||
|| time_id ||  uint32  || Random ID value included in wlan_exp TIME_INFO command; used to find common entries across nodes ||
|| reason ||  uint32  || Reason code for TIME_INFO log entry creation ||
|| mac_timestamp ||  uint64  || New value of microsecond MAC timer value ||
|| system_timestamp ||  uint64  || Value of microsecond System timer value ||
|| host_timestamp ||  uint64  || Host time in microseconds-since-epoch; 0xFFFFFFFFFFFFFFFF if unknown ||


----

=== Entry Type RX_OFDM ===
Rx events from OFDM PHY. These log entries will only be created for packets that are passed to the high-level MAC code in CPU High. If the low-level MAC filter drops the packet, it will not be logged. For full "monitor mode" ensure the low-level MAC filter is configured to pass all receptions up to CPU High.

Entry type ID: 10

||=  Field Name  =||=  Data Type  =||=  Description  =||
|| timestamp ||  uint64  || Microsecond timer value at PHY Rx start ||
|| timestamp_frac ||  uint8  || Fractional timestamp (units of 6.25ns) ||
|| phy_samp_rate ||  uint8  || PHY Sampling Rate Mode ||
|| length ||  uint16  || Length of payload in bytes ||
|| cfo_est ||  int32  || Time-domain CFO estimate from Rx PHY; Fix32_31 value, CFO as fraction of sampling frequency ||
|| mcs ||  uint8  || MCS index, in ![0:7] ||
|| phy_mode ||  uint8  || PHY mode ||
|| ant_mode ||  uint8  || Antenna mode: ![1,2,3,4] for SISO Rx on RF [A,B,C,D] ||
|| power ||  int8  || Rx power in dBm ||
|| fcs_result ||  uint8  || Checksum status, 0 = no errors ||
|| pkt_type ||  uint8  || Packet type: 1 = Other Data, 2 = Encapsulated Ethernet, 3 = LTG, 4 = Protected Data, 11 = Management, 21 = Control Ack, 22 = Control RTS, 23 = Control CTS ||
|| channel ||  uint8  || Channel (center frequency) index ||
|| padding ||  uint8  ||  ||
|| rf_gain ||  uint8  || AGC RF gain setting: ![1,2,3] for ![0,15,30]dB gain ||
|| bb_gain ||  uint8  || AGC BB gain setting: ![0:31] for approx ![0:63]dB gain ||
|| flags ||  uint16  || Bit OR'd flags: 0x1 = Rx was duplicate of previous Rx ||
|| chan_est ||  (64,2)i2  || OFDM Rx channel estimates, packed as [(uint16)I (uint16)Q] values, one per subcarrier ||
|| mac_payload_len ||  uint32  || Length in bytes of MAC payload recorded in log for this packet ||
|| mac_payload ||  24uint8  || First 24 bytes of MAC payload, typically the 802.11 MAC header ||


The following fields are populated when the log entry is part of a numpy array generated via the {{{generate_numpy_array}}} method. These fields are calculated from the underlying bytes in the raw log entries and are stored in more convenient formats tha the raw log fields. For example, these MAC address fields are 48-bit values stored in 64-bit integers. These integer addresses are much easier to use when filtering Tx/Rx log entries using numpy and pandas.

||=  Field Name  =||=  Data Type  =||=  Description  =||
|| addr1 ||  uint64  || MAC Header Address 1 ||
|| addr2 ||  uint64  || MAC Header Address 2 ||
|| addr3 ||  uint64  || MAC Header Address 3 ||
|| mac_seq ||  uint16  || MAC Header Sequence Number ||


----

=== Entry Type RX_OFDM_LTG ===
LTG Rx events from OFDM PHY. These log entries will only be created for packets that are passed to the high-level MAC code in CPU High. If the low-level MAC filter drops the packet, it will not be logged. For full "monitor mode" ensure the low-level MAC filter is configured to pass all receptions up to CPU High.

Entry type ID: 11

||=  Field Name  =||=  Data Type  =||=  Description  =||
|| timestamp ||  uint64  || Microsecond timer value at PHY Rx start ||
|| timestamp_frac ||  uint8  || Fractional timestamp (units of 6.25ns) ||
|| phy_samp_rate ||  uint8  || PHY Sampling Rate Mode ||
|| length ||  uint16  || Length of payload in bytes ||
|| cfo_est ||  int32  || Time-domain CFO estimate from Rx PHY; Fix32_31 value, CFO as fraction of sampling frequency ||
|| mcs ||  uint8  || MCS index, in ![0:7] ||
|| phy_mode ||  uint8  || PHY mode ||
|| ant_mode ||  uint8  || Antenna mode: ![1,2,3,4] for SISO Rx on RF [A,B,C,D] ||
|| power ||  int8  || Rx power in dBm ||
|| fcs_result ||  uint8  || Checksum status, 0 = no errors ||
|| pkt_type ||  uint8  || Packet type: 1 = Other Data, 2 = Encapsulated Ethernet, 3 = LTG, 4 = Protected Data, 11 = Management, 21 = Control Ack, 22 = Control RTS, 23 = Control CTS ||
|| channel ||  uint8  || Channel (center frequency) index ||
|| padding ||  uint8  ||  ||
|| rf_gain ||  uint8  || AGC RF gain setting: ![1,2,3] for ![0,15,30]dB gain ||
|| bb_gain ||  uint8  || AGC BB gain setting: ![0:31] for approx ![0:63]dB gain ||
|| flags ||  uint16  || Bit OR'd flags: 0x1 = Rx was duplicate of previous Rx ||
|| chan_est ||  (64,2)i2  || OFDM Rx channel estimates, packed as [(uint16)I (uint16)Q] values, one per subcarrier ||
|| mac_payload_len ||  uint32  || Length in bytes of MAC payload recorded in log for this packet ||
|| mac_payload ||  44uint8  || First 44 bytes of MAC payload: the 802.11 MAC header, LLC header, Packet ID, LTG ID ||


The following fields are populated when the log entry is part of a numpy array generated via the {{{generate_numpy_array}}} method. These fields are calculated from the underlying bytes in the raw log entries and are stored in more convenient formats tha the raw log fields. For example, these MAC address fields are 48-bit values stored in 64-bit integers. These integer addresses are much easier to use when filtering Tx/Rx log entries using numpy and pandas.

||=  Field Name  =||=  Data Type  =||=  Description  =||
|| addr1 ||  uint64  || MAC Header Address 1 ||
|| addr2 ||  uint64  || MAC Header Address 2 ||
|| addr3 ||  uint64  || MAC Header Address 3 ||
|| mac_seq ||  uint16  || MAC Header Sequence Number ||
|| ltg_uniq_seq ||  uint64  || Unique sequence number for LTG packet ||
|| ltg_flow_id ||  uint64  || LTG Flow ID, calculated as:[[BR]]  16LSB: LTG instance ID[[BR]]  48MSB: Destination MAC address ||


----

=== Entry Type RX_DSSS ===
Rx events from DSSS PHY. These log entries will only be created for packets that are passed to the high-level MAC code in CPU High. If the low-level MAC filter drops the packet, it will not be logged. For full "monitor mode" ensure the low-level MAC filter is configured to pass all receptions up to CPU High.

Entry type ID: 15

||=  Field Name  =||=  Data Type  =||=  Description  =||
|| timestamp ||  uint64  || Microsecond timer value at PHY Rx start ||
|| timestamp_frac ||  uint8  || Fractional timestamp (units of 6.25ns) ||
|| phy_samp_rate ||  uint8  || PHY Sampling Rate Mode ||
|| length ||  uint16  || Length of payload in bytes ||
|| cfo_est ||  int32  || Time-domain CFO estimate from Rx PHY; Fix32_31 value, CFO as fraction of sampling frequency ||
|| mcs ||  uint8  || MCS index, in ![0:7] ||
|| phy_mode ||  uint8  || PHY mode ||
|| ant_mode ||  uint8  || Antenna mode: ![1,2,3,4] for SISO Rx on RF [A,B,C,D] ||
|| power ||  int8  || Rx power in dBm ||
|| fcs_result ||  uint8  || Checksum status, 0 = no errors ||
|| pkt_type ||  uint8  || Packet type: 1 = Other Data, 2 = Encapsulated Ethernet, 3 = LTG, 4 = Protected Data, 11 = Management, 21 = Control Ack, 22 = Control RTS, 23 = Control CTS ||
|| channel ||  uint8  || Channel (center frequency) index ||
|| padding ||  uint8  ||  ||
|| rf_gain ||  uint8  || AGC RF gain setting: ![1,2,3] for ![0,15,30]dB gain ||
|| bb_gain ||  uint8  || AGC BB gain setting: ![0:31] for approx ![0:63]dB gain ||
|| flags ||  uint16  || Bit OR'd flags: 0x1 = Rx was duplicate of previous Rx ||
|| mac_payload_len ||  uint32  || Length in bytes of MAC payload recorded in log for this packet ||
|| mac_payload ||  24uint8  || First 24 bytes of MAC payload, typically the 802.11 MAC header ||


The following fields are populated when the log entry is part of a numpy array generated via the {{{generate_numpy_array}}} method. These fields are calculated from the underlying bytes in the raw log entries and are stored in more convenient formats tha the raw log fields. For example, these MAC address fields are 48-bit values stored in 64-bit integers. These integer addresses are much easier to use when filtering Tx/Rx log entries using numpy and pandas.

||=  Field Name  =||=  Data Type  =||=  Description  =||
|| addr1 ||  uint64  || MAC Header Address 1 ||
|| addr2 ||  uint64  || MAC Header Address 2 ||
|| addr3 ||  uint64  || MAC Header Address 3 ||
|| mac_seq ||  uint16  || MAC Header Sequence Number ||


----

=== Entry Type TX_HIGH ===
Tx events in CPU High, logged for each MPDU frame created and enqueued in CPU High. See TX_LOW for log entries of actual Tx events, including re-transmissions. The time values in this log entry can be used to determine time in queue (time_to_accept), time taken by CPU Low for all Tx attempts (time_to_done) and total time from creation to completion (time_to_accept+time_to_done).

Entry type ID: 20

||=  Field Name  =||=  Data Type  =||=  Description  =||
|| timestamp ||  uint64  || Microsecond timer value at time packet was created, immediately before it was enqueued ||
|| time_to_accept ||  uint32  || Time duration in microseconds between packet creation and packet acceptance by CPU Low ||
|| time_to_done ||  uint32  || Time duration in microseconds between packet acceptance by CPU Low and Tx completion in CPU Low ||
|| uniq_seq ||  uint64  || Unique sequence number for Tx packet; 12 LSB of this used for 802.11 MAC header sequence number ||
|| mcs ||  uint8  || MCS index in ![0:7] ||
|| phy_mode ||  uint8  || PHY mode ||
|| ant_mode ||  uint8  || PHY antenna mode in [0x10, 0x20, 0x30, 0x40] ||
|| tx_power ||  int8  || Tx power in dBm ||
|| num_tx ||  uint8  || Number of actual PHY Tx events which were used to transmit the MPDU (first Tx + all re-Tx) ||
|| padding0 ||  uint8  || Padding ||
|| length ||  uint16  || Length in bytes of MPDU; includes MAC header, payload and FCS ||
|| result ||  uint8  || Tx result; 0 = ACK received or not required ||
|| pkt_type ||  uint8  || Packet type: 1 = Other Data, 2 = Encapsulated Ethernet, 3 = LTG, 4 = Protected Data, 11 = Management, 21 = Control Ack, 22 = Control RTS, 23 = Control CTS ||
|| queue_id ||  uint16  || Tx queue ID from which the packet was retrieved ||
|| queue_occupancy ||  uint16  || Occupancy of the Tx queue at the time the packet was created (value includes itself) ||
|| padding ||  2uint8  ||  ||
|| mac_payload_len ||  uint32  || Length in bytes of MAC payload recorded in log for this packet ||
|| mac_payload ||  24uint8  || First 24 bytes of MAC payload, typically the 802.11 MAC header ||


The following fields are populated when the log entry is part of a numpy array generated via the {{{generate_numpy_array}}} method. These fields are calculated from the underlying bytes in the raw log entries and are stored in more convenient formats tha the raw log fields. For example, these MAC address fields are 48-bit values stored in 64-bit integers. These integer addresses are much easier to use when filtering Tx/Rx log entries using numpy and pandas.

||=  Field Name  =||=  Data Type  =||=  Description  =||
|| addr1 ||  uint64  || MAC Header Address 1 ||
|| addr2 ||  uint64  || MAC Header Address 2 ||
|| addr3 ||  uint64  || MAC Header Address 3 ||
|| mac_seq ||  uint16  || MAC Header Sequence Number ||


----

=== Entry Type TX_HIGH_LTG ===
Tx events in CPU High, logged for each MPDU frame created and enqueued in CPU High. See TX_LOW for log entries of actual Tx events, including re-transmissions. The time values in this log entry can be used to determine time in queue (time_to_accept), time taken by CPU Low for all Tx attempts (time_to_done) and total time from creation to completion (time_to_accept+time_to_done).

Entry type ID: 21

||=  Field Name  =||=  Data Type  =||=  Description  =||
|| timestamp ||  uint64  || Microsecond timer value at time packet was created, immediately before it was enqueued ||
|| time_to_accept ||  uint32  || Time duration in microseconds between packet creation and packet acceptance by CPU Low ||
|| time_to_done ||  uint32  || Time duration in microseconds between packet acceptance by CPU Low and Tx completion in CPU Low ||
|| uniq_seq ||  uint64  || Unique sequence number for Tx packet; 12 LSB of this used for 802.11 MAC header sequence number ||
|| mcs ||  uint8  || MCS index in ![0:7] ||
|| phy_mode ||  uint8  || PHY mode ||
|| ant_mode ||  uint8  || PHY antenna mode in [0x10, 0x20, 0x30, 0x40] ||
|| tx_power ||  int8  || Tx power in dBm ||
|| num_tx ||  uint8  || Number of actual PHY Tx events which were used to transmit the MPDU (first Tx + all re-Tx) ||
|| padding0 ||  uint8  || Padding ||
|| length ||  uint16  || Length in bytes of MPDU; includes MAC header, payload and FCS ||
|| result ||  uint8  || Tx result; 0 = ACK received or not required ||
|| pkt_type ||  uint8  || Packet type: 1 = Other Data, 2 = Encapsulated Ethernet, 3 = LTG, 4 = Protected Data, 11 = Management, 21 = Control Ack, 22 = Control RTS, 23 = Control CTS ||
|| queue_id ||  uint16  || Tx queue ID from which the packet was retrieved ||
|| queue_occupancy ||  uint16  || Occupancy of the Tx queue at the time the packet was created (value includes itself) ||
|| padding ||  2uint8  ||  ||
|| mac_payload_len ||  uint32  || Length in bytes of MAC payload recorded in log for this packet ||
|| mac_payload ||  44uint8  || First 44 bytes of MAC payload: the 802.11 MAC header, LLC header, Packet ID, LTG ID ||


The following fields are populated when the log entry is part of a numpy array generated via the {{{generate_numpy_array}}} method. These fields are calculated from the underlying bytes in the raw log entries and are stored in more convenient formats tha the raw log fields. For example, these MAC address fields are 48-bit values stored in 64-bit integers. These integer addresses are much easier to use when filtering Tx/Rx log entries using numpy and pandas.

||=  Field Name  =||=  Data Type  =||=  Description  =||
|| addr1 ||  uint64  || MAC Header Address 1 ||
|| addr2 ||  uint64  || MAC Header Address 2 ||
|| addr3 ||  uint64  || MAC Header Address 3 ||
|| mac_seq ||  uint16  || MAC Header Sequence Number ||
|| ltg_uniq_seq ||  uint64  || Unique sequence number for LTG packet ||
|| ltg_flow_id ||  uint64  || LTG Flow ID, calculated as:[[BR]]  16LSB: LTG instance ID[[BR]]  48MSB: Destination MAC address ||


----

=== Entry Type TX_LOW ===
Record of actual PHY transmission. At least one TX_LOW will be logged for every TX entry. Multiple TX_LOW entries may be created for the same TX entry if the low-level MAC re-transmitted the frame. The uniq_seq fields can be match between TX and TX_LOW entries to find records common to the same MPUD.

Entry type ID: 25

||=  Field Name  =||=  Data Type  =||=  Description  =||
|| timestamp ||  uint64  || Microsecond timer value at time packet transmission actually started (PHY TX_START time) ||
|| uniq_seq ||  uint64  || Unique sequence number of original MPDU ||
|| mcs ||  uint8  || MCS index in ![0:7] ||
|| phy_mode ||  uint8  || PHY mode ||
|| ant_mode ||  uint8  || PHY antenna mode in [0x10, 0x20, 0x30, 0x40] ||
|| tx_power ||  int8  || Tx power in dBm ||
|| tx_count ||  uint8  || Transmission index for this attempt; 0 = initial Tx, 1+ = subsequent re-transmissions ||
|| channel ||  uint8  || Channel (center frequency) index ||
|| length ||  uint16  || Length in bytes of MPDU; includes MAC header, payload and FCS ||
|| num_slots ||  int16  || Number of backoff slots allotted prior to this transmission; may not have been used for initial Tx (tx_count==0); A value of -1 in this field means no backoff occured ||
|| cw ||  uint16  || Contention window value at time of this Tx ||
|| pkt_type ||  uint8  || Packet type: 1 = Other Data, 2 = Encapsulated Ethernet, 3 = LTG, 4 = Protected Data, 11 = Management, 21 = Control Ack, 22 = Control RTS, 23 = Control CTS ||
|| flags ||  uint8  || B0: 1 = ACKed, 0 = Not ACKed ||
|| timestamp_frac ||  uint8  || Fractional timestamp (units of 6.25ns) ||
|| phy_samp_rate ||  uint8  || PHY Sampling Rate Mode ||
|| mac_payload_len ||  uint32  || Length in bytes of MAC payload recorded in log for this packet ||
|| mac_payload ||  24uint8  || First 24 bytes of MAC payload, typically the 802.11 MAC header ||


The following fields are populated when the log entry is part of a numpy array generated via the {{{generate_numpy_array}}} method. These fields are calculated from the underlying bytes in the raw log entries and are stored in more convenient formats tha the raw log fields. For example, these MAC address fields are 48-bit values stored in 64-bit integers. These integer addresses are much easier to use when filtering Tx/Rx log entries using numpy and pandas.

||=  Field Name  =||=  Data Type  =||=  Description  =||
|| addr1 ||  uint64  || MAC Header Address 1 ||
|| addr2 ||  uint64  || MAC Header Address 2 ||
|| addr3 ||  uint64  || MAC Header Address 3 ||
|| mac_seq ||  uint16  || MAC Header Sequence Number ||


----

=== Entry Type TX_LOW_LTG ===
Record of actual PHY transmission. At least one TX_LOW will be logged for every TX entry. Multiple TX_LOW entries may be created for the same TX entry if the low-level MAC re-transmitted the frame. The uniq_seq fields can be match between TX and TX_LOW entries to find records common to the same MPUD.

Entry type ID: 26

||=  Field Name  =||=  Data Type  =||=  Description  =||
|| timestamp ||  uint64  || Microsecond timer value at time packet transmission actually started (PHY TX_START time) ||
|| uniq_seq ||  uint64  || Unique sequence number of original MPDU ||
|| mcs ||  uint8  || MCS index in ![0:7] ||
|| phy_mode ||  uint8  || PHY mode ||
|| ant_mode ||  uint8  || PHY antenna mode in [0x10, 0x20, 0x30, 0x40] ||
|| tx_power ||  int8  || Tx power in dBm ||
|| tx_count ||  uint8  || Transmission index for this attempt; 0 = initial Tx, 1+ = subsequent re-transmissions ||
|| channel ||  uint8  || Channel (center frequency) index ||
|| length ||  uint16  || Length in bytes of MPDU; includes MAC header, payload and FCS ||
|| num_slots ||  int16  || Number of backoff slots allotted prior to this transmission; may not have been used for initial Tx (tx_count==0); A value of -1 in this field means no backoff occured ||
|| cw ||  uint16  || Contention window value at time of this Tx ||
|| pkt_type ||  uint8  || Packet type: 1 = Other Data, 2 = Encapsulated Ethernet, 3 = LTG, 4 = Protected Data, 11 = Management, 21 = Control Ack, 22 = Control RTS, 23 = Control CTS ||
|| flags ||  uint8  || B0: 1 = ACKed, 0 = Not ACKed ||
|| timestamp_frac ||  uint8  || Fractional timestamp (units of 6.25ns) ||
|| phy_samp_rate ||  uint8  || PHY Sampling Rate Mode ||
|| mac_payload_len ||  uint32  || Length in bytes of MAC payload recorded in log for this packet ||
|| mac_payload ||  44uint8  || First 44 bytes of MAC payload: the 802.11 MAC header, LLC header, Packet ID, LTG ID ||


The following fields are populated when the log entry is part of a numpy array generated via the {{{generate_numpy_array}}} method. These fields are calculated from the underlying bytes in the raw log entries and are stored in more convenient formats tha the raw log fields. For example, these MAC address fields are 48-bit values stored in 64-bit integers. These integer addresses are much easier to use when filtering Tx/Rx log entries using numpy and pandas.

||=  Field Name  =||=  Data Type  =||=  Description  =||
|| addr1 ||  uint64  || MAC Header Address 1 ||
|| addr2 ||  uint64  || MAC Header Address 2 ||
|| addr3 ||  uint64  || MAC Header Address 3 ||
|| mac_seq ||  uint16  || MAC Header Sequence Number ||
|| ltg_uniq_seq ||  uint64  || Unique sequence number for LTG packet ||
|| ltg_flow_id ||  uint64  || LTG Flow ID, calculated as:[[BR]]  16LSB: LTG instance ID[[BR]]  48MSB: Destination MAC address ||

